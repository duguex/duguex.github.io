<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"tobedetermined.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="install deb packageGitHub Copilot: You can install a .deb package on Ubuntu using the dpkg command. Here are the steps:  Open a terminal window.  Navigate to the directory where the .deb package is lo">
<meta property="og:type" content="article">
<meta property="og:title" content="linux">
<meta property="og:url" content="http://tobedetermined.com/2024/06/15/linux/index.html">
<meta property="og:site_name" content="TODO">
<meta property="og:description" content="install deb packageGitHub Copilot: You can install a .deb package on Ubuntu using the dpkg command. Here are the steps:  Open a terminal window.  Navigate to the directory where the .deb package is lo">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://tobedetermined.com/image-12.png">
<meta property="og:image" content="https://img.shields.io/github/license/NVIDIA/nvidia-docker?style=flat-square">
<meta property="og:image" content="https://img.shields.io/badge/documentation-wiki-blue.svg?style=flat-square">
<meta property="og:image" content="https://img.shields.io/badge/packages-repository-b956e8.svg?style=flat-square">
<meta property="og:image" content="https://cloud.githubusercontent.com/assets/3028125/12213714/5b208976-b632-11e5-8406-38d379ec46aa.png">
<meta property="og:image" content="http://tobedetermined.com/image.png">
<meta property="article:published_time" content="2024-06-15T13:04:09.000Z">
<meta property="article:modified_time" content="2024-07-29T16:45:20.856Z">
<meta property="article:author" content="Mingzhe Liu">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://tobedetermined.com/image-12.png">


<link rel="canonical" href="http://tobedetermined.com/2024/06/15/linux/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://tobedetermined.com/2024/06/15/linux/","path":"2024/06/15/linux/","title":"linux"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>linux | TODO</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">TODO</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#install-deb-package"><span class="nav-number">1.</span> <span class="nav-text">install deb package</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#tee"><span class="nav-number">2.</span> <span class="nav-text">tee</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#install-miniconda-on-linux"><span class="nav-number">3.</span> <span class="nav-text">install miniconda on linux</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#nvidia-smi"><span class="nav-number">4.</span> <span class="nav-text">nvidia-smi</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#scp"><span class="nav-number">5.</span> <span class="nav-text">scp</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ssh"><span class="nav-number">6.</span> <span class="nav-text">ssh</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#wget"><span class="nav-number">7.</span> <span class="nav-text">wget</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ubuntu-install-conda"><span class="nav-number">8.</span> <span class="nav-text">ubuntu install conda</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#install"><span class="nav-number">8.1.</span> <span class="nav-text">install</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#config"><span class="nav-number">8.2.</span> <span class="nav-text">config</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#install-oneapi"><span class="nav-number">9.</span> <span class="nav-text">install oneapi</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#xrdp-connect-to-ubuntu"><span class="nav-number">10.</span> <span class="nav-text">xrdp connect to ubuntu</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#apt-intall-openmpi"><span class="nav-number">11.</span> <span class="nav-text">apt intall openmpi</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#sed"><span class="nav-number">12.</span> <span class="nav-text">sed</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ZFS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8C%82%E8%BD%BD%E7%A1%AC%E7%9B%98"><span class="nav-number">13.</span> <span class="nav-text">ZFS文件系统挂载硬盘</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#docker"><span class="nav-number">14.</span> <span class="nav-text">docker</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#NVIDIA-Container-Toolkit"><span class="nav-number">15.</span> <span class="nav-text">NVIDIA Container Toolkit</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Introduction"><span class="nav-number">15.1.</span> <span class="nav-text">Introduction</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Getting-Started"><span class="nav-number">15.2.</span> <span class="nav-text">Getting Started</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Usage"><span class="nav-number">15.3.</span> <span class="nav-text">Usage</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#remove-%E5%88%A0%E9%99%A4docker-push-registry%E7%9A%84%E9%95%9C%E5%83%8F"><span class="nav-number">16.</span> <span class="nav-text">remove 删除docker push registry的镜像</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Start-a-docker-registry"><span class="nav-number">17.</span> <span class="nav-text">Start a docker registry</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Push-local-docker-container-to-it"><span class="nav-number">18.</span> <span class="nav-text">Push local docker container to it</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Create-def-file-for-singularity-like-this"><span class="nav-number">19.</span> <span class="nav-text">Create def file for singularity like this..</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#add-your-modifications"><span class="nav-number">20.</span> <span class="nav-text">(add your modifications)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Build-singularity-container"><span class="nav-number">21.</span> <span class="nav-text">Build singularity container</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#install-docker-on-ubuntu"><span class="nav-number">21.1.</span> <span class="nav-text">install docker on ubuntu</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Add-Docker%E2%80%99s-official-GPG-key"><span class="nav-number">22.</span> <span class="nav-text">Add Docker’s official GPG key:</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Add-the-repository-to-Apt-sources"><span class="nav-number">23.</span> <span class="nav-text">Add the repository to Apt sources:</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#On-the-host-where-you-run-docker-find-the-image-ID-of-the-docker-image-you-want-to-convert"><span class="nav-number">24.</span> <span class="nav-text">On the host where you run docker, find the image ID of the docker image you want to convert</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Save-the-docker-image-as-a-tarball-e-g-lolcow-tar"><span class="nav-number">25.</span> <span class="nav-text">Save the docker image as a tarball, e.g. lolcow.tar</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0"><span class="nav-number">25.1.</span> <span class="nav-text">更新</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#http-server-gave-HTTP-response-to-HTTPS-client"><span class="nav-number">26.</span> <span class="nav-text">http: server gave HTTP response to HTTPS client</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#install-singularity"><span class="nav-number">27.</span> <span class="nav-text">install singularity</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#singularity-with-nvidia-%E2%80%93nv"><span class="nav-number">28.</span> <span class="nav-text">singularity with nvidia –nv</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B8%85%E7%90%86-singularity-%E7%BC%93%E5%AD%98"><span class="nav-number">29.</span> <span class="nav-text">清理 singularity 缓存</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B0%86%E6%96%B0%E7%A1%AC%E7%9B%98%E5%86%85%E5%AE%B9%E7%A7%BB%E5%88%B0Linux%E6%9C%BA%E5%99%A8"><span class="nav-number">30.</span> <span class="nav-text">将新硬盘内容移到Linux机器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#adduser%E5%92%8Cdeluser%E5%91%BD%E4%BB%A4"><span class="nav-number">31.</span> <span class="nav-text">adduser和deluser命令</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#bash-shell%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="nav-number">32.</span> <span class="nav-text">bash shell的执行顺序如下：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#is-enabled"><span class="nav-number">33.</span> <span class="nav-text">is-enabled</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#shell-%E4%B8%AD%E5%8D%95%E5%BC%95%E5%8F%B7%E5%92%8C%E5%8F%8C%E5%BC%95%E5%8F%B7%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">34.</span> <span class="nav-text">shell 中单引号和双引号的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E6%9C%8D%E5%8A%A1%E5%99%A8cpu%E6%98%AF%E5%90%A6%E5%BC%80%E5%90%AF%E4%BA%86%E8%B6%85%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="nav-number">35.</span> <span class="nav-text">如何知道服务器cpu是否开启了超线程？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#sudo-apt-update-error"><span class="nav-number">36.</span> <span class="nav-text">sudo apt update error</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#mpirun-v-s-mpiexec"><span class="nav-number">37.</span> <span class="nav-text">mpirun v.s. mpiexec</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#neofetch"><span class="nav-number">38.</span> <span class="nav-text">neofetch</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#linux-service-daemon"><span class="nav-number">39.</span> <span class="nav-text">linux service daemon</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E8%8A%82-%E7%AE%80%E4%BB%8B"><span class="nav-number">39.1.</span> <span class="nav-text">第一节:简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E8%8A%82-serivces%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E"><span class="nav-number">39.2.</span> <span class="nav-text">第二节: serivces配置文件说明:</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E5%91%BD%E4%BB%A4"><span class="nav-number">39.2.1.</span> <span class="nav-text">启动命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E7%B1%BB%E5%9E%8B"><span class="nav-number">39.2.2.</span> <span class="nav-text">启动类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E5%90%AF%E8%A1%8C%E4%B8%BA"><span class="nav-number">39.2.3.</span> <span class="nav-text">重启行为</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E8%8A%82-%E6%B3%A8%E5%86%8C%E6%9C%8D%E5%8A%A1%E5%AE%9E%E4%BE%8B%E4%BB%8B%E7%BB%8D"><span class="nav-number">39.3.</span> <span class="nav-text">第三节: 注册服务实例介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E8%8A%82-%E4%BD%BF%E7%94%A8svstemd%E7%AE%A1%E7%90%86Altas"><span class="nav-number">39.4.</span> <span class="nav-text">第四节: 使用svstemd管理Altas</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E8%8A%82-%E5%90%AF%E5%8A%A8%E5%88%86%E6%9E%90"><span class="nav-number">39.5.</span> <span class="nav-text">第五节 启动分析</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#jq"><span class="nav-number">40.</span> <span class="nav-text">jq</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#linux-notebook-ban-suspend"><span class="nav-number">41.</span> <span class="nav-text">linux notebook ban suspend</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#uninstall-cuda"><span class="nav-number">42.</span> <span class="nav-text">uninstall cuda</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#remove-docker-from-apt-update"><span class="nav-number">43.</span> <span class="nav-text">remove docker from apt update</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#shebang"><span class="nav-number">44.</span> <span class="nav-text">shebang</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#nvidia-smi-ecc-%E6%8A%A5%E9%94%99"><span class="nav-number">45.</span> <span class="nav-text">nvidia-smi ecc 报错</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Mingzhe Liu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/duguex" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;duguex" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:duguex@126.com" title="E-Mail → mailto:duguex@126.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://tobedetermined.com/2024/06/15/linux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mingzhe Liu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TODO">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="linux | TODO">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          linux
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-06-15 21:04:09" itemprop="dateCreated datePublished" datetime="2024-06-15T21:04:09+08:00">2024-06-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-07-30 00:45:20" itemprop="dateModified" datetime="2024-07-30T00:45:20+08:00">2024-07-30</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="install-deb-package"><a href="#install-deb-package" class="headerlink" title="install deb package"></a>install deb package</h1><p>GitHub Copilot: You can install a <code>.deb</code> package on Ubuntu using the <code>dpkg</code> command. Here are the steps:</p>
<ol>
<li><p>Open a terminal window.</p>
</li>
<li><p>Navigate to the directory where the <code>.deb</code> package is located.</p>
</li>
<li><p>Run the following command to install the package:</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i package_name.deb</span><br></pre></td></tr></table></figure>

<p>Replace <code>package_name.deb</code> with the name of the <code>.deb</code> package you want to install.</p>
<ol start="4">
<li>If the installation is successful, you can run the following command to check the installed package:</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -l | grep package_name</span><br></pre></td></tr></table></figure>

<p>Replace <code>package_name</code> with the name of the package you just installed.</p>
<p>This will display information about the installed package, including the version number.</p>
<p>Note that you may need to have root privileges to install a <code>.deb</code> package.</p>
<h1 id="tee"><a href="#tee" class="headerlink" title="tee"></a>tee</h1><p>在 Unix&#x2F;Linux shell 中，你可以使用 <code>tee</code> 命令将输出同时发送到屏幕和文件。以下是一个示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello, World!&quot;</span> | <span class="built_in">tee</span> output.txt</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>echo &quot;Hello, World!&quot;</code> 会产生一个消息，然后 <code>|</code> 将这个消息传递给 <code>tee output.txt</code>。<code>tee</code> 命令会将接收到的输入同时显示在屏幕上，并写入到 <code>output.txt</code> 文件中。</p>
<p>如果你想在已有的文件后面追加消息，而不是覆盖文件，你可以使用 <code>-a</code> 选项：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello, World!&quot;</span> | <span class="built_in">tee</span> -a output.txt</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>tee -a output.txt</code> 会将接收到的输入追加到 <code>output.txt</code> 文件的末尾，而不是覆盖文件。</p>
<p>在 Linux 系统中，你可以使用 <code>tail -f</code> 命令来查看一个正在写入的文件。这个命令会显示文件的最后几行，并且当文件被更新时，新的内容会被立即显示出来。</p>
<p>以下是基本的使用方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tail</span> -f &lt;filename&gt;</span><br></pre></td></tr></table></figure>

<p>在这个命令中，<code>&lt;filename&gt;</code> 是你想要查看的文件的名称。</p>
<p>例如，如果你想要查看一个名为 <code>logfile.log</code> 的正在写入的文件，你可以运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tail</span> -f logfile.log</span><br></pre></td></tr></table></figure>

<p>这个命令会显示 <code>logfile.log</code> 文件的最后几行，当 <code>logfile.log</code> 文件被更新时，新的内容会被立即显示出来。</p>
<p>请注意，<code>tail -f</code> 命令会一直运行，直到你按下 <code>Ctrl + C</code> 来停止它。</p>
<h1 id="install-miniconda-on-linux"><a href="#install-miniconda-on-linux" class="headerlink" title="install miniconda on linux"></a>install miniconda on linux</h1><p>These four commands quickly and quietly install the latest 64-bit version of the installer and then clean up after themselves. To install a different version or architecture of Miniconda for Linux, change the name of the .sh installer in the wget command.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/miniconda3</span><br><span class="line">wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh -O ~/miniconda3/miniconda.sh</span><br><span class="line">bash ~/miniconda3/miniconda.sh -b -u -p ~/miniconda3</span><br><span class="line">rm -rf ~/miniconda3/miniconda.sh</span><br></pre></td></tr></table></figure>

<p>After installing, initialize your newly-installed Miniconda. The following commands initialize for bash and zsh shells:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/miniconda3/bin/conda init bash</span><br><span class="line">~/miniconda3/bin/conda init zsh</span><br></pre></td></tr></table></figure>

<h1 id="nvidia-smi"><a href="#nvidia-smi" class="headerlink" title="nvidia-smi"></a>nvidia-smi</h1><p>System Management Interface<br>Sun Oct  1 07:44:46 2023<br>+—————————————————————————————+<br>| NVIDIA-SMI 535.104.07             Driver Version: 537.34       CUDA Version: 12.2     |<br>|—————————————–+———————-+———————-+<br>| GPU  Name                 Persistence-M | Bus-Id        Disp.A | Volatile Uncorr. ECC |<br>| Fan  Temp   Perf          Pwr:Usage&#x2F;Cap |         Memory-Usage | GPU-Util  Compute M. |<br>|                                         |                      |               MIG M. |<br>|&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|<br>|   0  NVIDIA GeForce RTX 3060 …    On  | 00000000:07:00.0  On |                  N&#x2F;A |<br>| N&#x2F;A   47C    P8              15W &#x2F; 115W |    548MiB &#x2F;  6144MiB |      5%      Default |<br>|                                         |                      |                  N&#x2F;A |<br>+—————————————–+———————-+———————-+</p>
<p>+—————————————————————————————+<br>| Processes:                                                                            |<br>|  GPU   GI   CI        PID   Type   Process name                            GPU Memory |<br>|        ID   ID                                                             Usage      |<br>|&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|<br>|    0   N&#x2F;A  N&#x2F;A        23      G   &#x2F;Xwayland                                 N&#x2F;A      |<br>+—————————————————————————————+</p>
<h1 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h1><p>scp -P 22 -r source_directory username@destination:&#x2F;path&#x2F;to&#x2F;destination</p>
<p>在两台服务器之间设置 SSH 公钥认证，你需要按照以下步骤操作：</p>
<ol>
<li>在源服务器上生成 SSH 密钥对。如果你已经有一个密钥对，你可以跳过这一步。在终端中输入以下命令：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure>

<p>按照提示进行操作。这将在你的 <code>~/.ssh</code> 目录下生成两个文件：<code>id_rsa</code>（私钥）和 <code>id_rsa.pub</code>（公钥）。</p>
<ol start="2">
<li>将你的公钥复制到目标服务器。你可以使用 <code>ssh-copy-id</code> 命令来完成这一步。在终端中输入以下命令：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id username@destination</span><br></pre></td></tr></table></figure>
<p>ssh-copy-id <a href="mailto:&#x71;&#x69;&#102;&#64;&#x32;&#49;&#x31;&#x2e;&#x38;&#x36;&#46;&#49;&#x35;&#49;&#46;&#x31;&#48;&#54;">&#x71;&#x69;&#102;&#64;&#x32;&#49;&#x31;&#x2e;&#x38;&#x36;&#46;&#49;&#x35;&#49;&#46;&#x31;&#48;&#54;</a></p>
<p>ssh-copy-id <a href="mailto:&#99;&#x6b;&#100;&#x75;&#97;&#110;&#x31;&#64;&#x32;&#x31;&#49;&#46;&#56;&#54;&#x2e;&#x31;&#53;&#x31;&#46;&#x31;&#x30;&#x36;">&#99;&#x6b;&#100;&#x75;&#97;&#110;&#x31;&#64;&#x32;&#x31;&#49;&#46;&#56;&#54;&#x2e;&#x31;&#53;&#x31;&#46;&#x31;&#x30;&#x36;</a><br>在这个命令中，<code>username@destination</code> 是目标服务器的用户名和地址。这个命令会提示你输入目标服务器的密码。</p>
<p>完成以上步骤后，你就可以在不输入密码的情况下从源服务器 SSH 到目标服务器了。这也意味着你可以使用 <code>scp</code> 命令在两台服务器之间复制文件或目录，而不需要输入密码。</p>
<h1 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h1><p>在 Ubuntu 上配置 SSH 首次使用，你可以按照以下步骤进行：</p>
<ol>
<li>首先，你需要安装 OpenSSH 服务器。在终端中输入以下命令：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>安装完成后，SSH 服务应该会自动启动。你可以使用以下命令来检查 SSH 服务的状态：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status ssh</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>如果你需要在启动时自动启动 SSH 服务，你可以使用以下命令：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> ssh</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>默认情况下，你应该已经可以通过 SSH 连接到你的机器了。如果你想修改 SSH 的配置（例如更改默认的端口号或禁用密码认证），你可以编辑 <code>/etc/ssh/sshd_config</code> 文件。编辑完成后，你需要重启 SSH 服务以使更改生效：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart ssh</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在客户端机器上，你可以使用 <code>ssh</code> 命令和你的用户名以及服务器的 IP 地址来连接到服务器：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh username@server_ip</span><br></pre></td></tr></table></figure>

<p>请注意，以上步骤可能需要管理员权限。</p>
<h1 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h1><p>wget：这是一个自由的网络下载工具，可以从网络上下载文件。<br>-q：这是 wget 的一个选项，表示 “quiet”（安静）。当这个选项被使用时，wget 不会输出任何下载进度信息。<br>O -：这是 wget 的一个选项，表示将下载的文件输出到标准输出（stdout）。- 表示标准输出。<br><a target="_blank" rel="noopener" href="https://apt.v2raya.mzz.pub/key/public-key.asc%EF%BC%9A%E8%BF%99%E6%98%AF%E4%BD%A0%E6%83%B3%E8%A6%81%E4%B8%8B%E8%BD%BD%E7%9A%84%E6%96%87%E4%BB%B6%E7%9A%84">https://apt.v2raya.mzz.pub/key/public-key.asc：这是你想要下载的文件的</a> URL。<br>因此，wget -qO - <a target="_blank" rel="noopener" href="https://apt.v2raya.mzz.pub/key/public-key.asc">https://apt.v2raya.mzz.pub/key/public-key.asc</a> 命令会安静地从指定的 URL 下载文件，并将其输出到标准输出。这个命令通常与其他命令一起使用，例如 apt-key add - 或 gpg –import -，来添加 GPG 密钥。</p>
<h1 id="ubuntu-install-conda"><a href="#ubuntu-install-conda" class="headerlink" title="ubuntu install conda"></a>ubuntu install conda</h1><h2 id="install"><a href="#install" class="headerlink" title="install"></a>install</h2><p>sudo apt update &amp;&amp; sudo apt upgrade &amp;&amp; sudo apt install curl gpg &amp;&amp; curl <a target="_blank" rel="noopener" href="https://repo.anaconda.com/pkgs/misc/gpgkeys/anaconda.asc">https://repo.anaconda.com/pkgs/misc/gpgkeys/anaconda.asc</a> | gpg –dearmor &gt; conda.gpg &amp;&amp; sudo install -o root -g root -m 644 conda.gpg &#x2F;usr&#x2F;share&#x2F;keyrings&#x2F;conda-archive-keyring.gpg &amp;&amp; gpg –keyring &#x2F;usr&#x2F;share&#x2F;keyrings&#x2F;conda-archive-keyring.gpg –no-default-keyring –fingerprint 34161F5BF5EB1D4BFBBB8F0A8AEB4F8B29D82806 &amp;&amp; sudo echo “deb [arch&#x3D;amd64 signed-by&#x3D;&#x2F;usr&#x2F;share&#x2F;keyrings&#x2F;conda-archive-keyring.gpg] <a target="_blank" rel="noopener" href="https://repo.anaconda.com/pkgs/misc/debrepo/conda">https://repo.anaconda.com/pkgs/misc/debrepo/conda</a> stable main” | sudo tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;conda.list &amp;&amp; sudo apt update &amp;&amp; sudo apt install conda;</p>
<h2 id="config"><a href="#config" class="headerlink" title="config"></a>config</h2><p>source &#x2F;opt&#x2F;conda&#x2F;etc&#x2F;profile.d&#x2F;conda.sh &amp;&amp; conda init;</p>
<p>sudo apt update &amp;&amp; sudo apt upgrade &amp;&amp; sudo apt install curl gpg &amp;&amp; curl <a target="_blank" rel="noopener" href="https://repo.anaconda.com/pkgs/misc/gpgkeys/anaconda.asc">https://repo.anaconda.com/pkgs/misc/gpgkeys/anaconda.asc</a> | gpg –dearmor &gt; conda.gpg &amp;&amp; sudo install -o root -g root -m 644 conda.gpg &#x2F;usr&#x2F;share&#x2F;keyrings&#x2F;conda-archive-keyring.gpg &amp;&amp; gpg –keyring &#x2F;usr&#x2F;share&#x2F;keyrings&#x2F;conda-archive-keyring.gpg –no-default-keyring –fingerprint 34161F5BF5EB1D4BFBBB8F0A8AEB4F8B29D82806 &amp;&amp; sudo echo “deb [arch&#x3D;amd64 signed-by&#x3D;&#x2F;usr&#x2F;share&#x2F;keyrings&#x2F;conda-archive-keyring.gpg] <a target="_blank" rel="noopener" href="https://repo.anaconda.com/pkgs/misc/debrepo/conda">https://repo.anaconda.com/pkgs/misc/debrepo/conda</a> stable main” | sudo tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;conda.list &amp;&amp; sudo apt update &amp;&amp; sudo apt install conda &amp;&amp; source &#x2F;opt&#x2F;conda&#x2F;etc&#x2F;profile.d&#x2F;conda.sh &amp;&amp; conda init;</p>
<p>conda create -n zfs -y &amp;&amp; conda activate zfs &amp;&amp; conda install -c conda-forge -y mpi4py &amp;&amp; conda install -c anaconda -y numpy scipy</p>
<h1 id="install-oneapi"><a href="#install-oneapi" class="headerlink" title="install oneapi"></a>install oneapi</h1><p>apt install gpg wget</p>
<p>wget -O- <a target="_blank" rel="noopener" href="https://apt.repos.intel.com/intel-gpg-keys/GPG-PUB-KEY-INTEL-SW-PRODUCTS.PUB">https://apt.repos.intel.com/intel-gpg-keys/GPG-PUB-KEY-INTEL-SW-PRODUCTS.PUB</a> | gpg –dearmor | tee &#x2F;usr&#x2F;share&#x2F;keyrings&#x2F;oneapi-archive-keyring.gpg &gt; &#x2F;dev&#x2F;null;</p>
<p>echo “deb [signed-by&#x3D;&#x2F;usr&#x2F;share&#x2F;keyrings&#x2F;oneapi-archive-keyring.gpg] <a target="_blank" rel="noopener" href="https://apt.repos.intel.com/oneapi">https://apt.repos.intel.com/oneapi</a> all main” | tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;oneAPI.list;</p>
<p>apt update;<br>apt install -y intel-basekit intel-hpckit;</p>
<p>–report-bindings：这是一个选项，表示报告每个 MPI 进程的绑定信息。绑定信息是指每个 MPI 进程被绑定到哪些 CPU 核心上。</p>
<p>-np $NUM_MPI_RANKS：这是一个选项，表示启动的 MPI 进程数。$NUM_MPI_RANKS 是一个环境变量，表示 MPI 进程数。</p>
<p>${2}：这是一个 shell 变量，表示命令行的第二个参数。</p>
<p>–map-by ppr:${MPI_RANK_L3}:l3cache:pe&#x3D;$OMP_NUM_THREADS：这是一个选项，表示如何将 MPI 进程映射到 CPU 核心上。ppr:${MPI_RANK_L3}:l3cache 表示每个 L3 缓存区域有 ${MPI_RANK_L3} 个 MPI 进程，pe&#x3D;$OMP_NUM_THREADS 表示每个 MPI 进程有 $OMP_NUM_THREADS 个并行执行的线程。</p>
<p>-x UCX_TLS&#x3D;self,sm,rc_x：这是一个选项，表示设置环境变量 UCX_TLS 的值为 self,sm,rc_x。UCX_TLS 是 UCX（Unified Communication X）的一个环境变量，用于指定通信的传输层。</p>
<h1 id="xrdp-connect-to-ubuntu"><a href="#xrdp-connect-to-ubuntu" class="headerlink" title="xrdp connect to ubuntu"></a>xrdp connect to ubuntu</h1><p>need logout locally and login remotely</p>
<h1 id="apt-intall-openmpi"><a href="#apt-intall-openmpi" class="headerlink" title="apt intall openmpi"></a>apt intall openmpi</h1><p>sudo apt install libopenmpi-dev</p>
<h1 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h1><p>在 sed 命令中，你可以使用任何字符作为分隔符，只要它不出现在模式或替换字符串中。所以，如果你想要替换 &#x2F; 字符，你可以选择一个不会出现在你的模式或替换字符串中的字符作为分隔符。</p>
<p>例如，你可以使用 # 作为分隔符，将 &#x2F; 替换为空格：</p>
<p>在这个命令中，s 是 sed 的替换命令，# 是分隔符，&#x2F; 是你要替换的模式， （空格）是你要替换成的字符串，g 是一个选项，表示全局替换（替换每一行中的所有匹配）。</p>
<h1 id="ZFS文件系统挂载硬盘"><a href="#ZFS文件系统挂载硬盘" class="headerlink" title="ZFS文件系统挂载硬盘"></a>ZFS文件系统挂载硬盘</h1><p>lsblk -f<br>df -h<br>zpool list rpool<br>sudo zpool add rpool &#x2F;dev&#x2F;sdc<br>zpool status rpool</p>
<h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><p>docker run -it –gpus&#x3D;all –rm nvcr.io&#x2F;nvidia&#x2F;k8s&#x2F;cuda-sample:nbody nbody -benchmark</p>
<p>Run “nbody -benchmark [-numbodies&#x3D;<numBodies>]” to measure performance.<br>        -fullscreen       (run n-body simulation in fullscreen mode)<br>        -fp64             (use double precision floating point values for simulation)<br>        -hostmem          (stores simulation data in host memory)<br>        -benchmark        (run benchmark to measure performance)<br>        -numbodies&#x3D;<N>    (number of bodies (&gt;&#x3D; 1) to run in simulation)<br>        -device&#x3D;<d>       (where d&#x3D;0,1,2…. for the CUDA device to use)<br>        -numdevices&#x3D;<i>   (where i&#x3D;(number of CUDA devices &gt; 0) to use for simulation)<br>        -compare          (compares simulation results running once on the default GPU and once on the CPU)<br>        -cpu              (run n-body simulation on the CPU)<br>        -tipsy&#x3D;&lt;file.bin&gt; (load a tipsy model file for simulation)</p>
<blockquote>
<p>Compute 8.6 CUDA device: [NVIDIA GeForce RTX 3060 Laptop GPU]<br>30720 bodies, total time for 10 iterations: 26.021 ms<br>&#x3D; 362.678 billion interactions per second<br>&#x3D; 7253.551 single-precision GFLOP&#x2F;s at 20 flops per interaction</p>
</blockquote>
<p><img src="/image-12.png" alt="docker and cuda"></p>
<h1 id="NVIDIA-Container-Toolkit"><a href="#NVIDIA-Container-Toolkit" class="headerlink" title="NVIDIA Container Toolkit"></a>NVIDIA Container Toolkit</h1><p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/NVIDIA/nvidia-docker/master/LICENSE"><img src="https://img.shields.io/github/license/NVIDIA/nvidia-docker?style=flat-square" alt="GitHub license"></a><br><a target="_blank" rel="noopener" href="https://github.com/NVIDIA/nvidia-docker/wiki"><img src="https://img.shields.io/badge/documentation-wiki-blue.svg?style=flat-square" alt="Documentation"></a><br><a target="_blank" rel="noopener" href="https://nvidia.github.io/nvidia-docker"><img src="https://img.shields.io/badge/packages-repository-b956e8.svg?style=flat-square" alt="Package repository"></a></p>
<p><img src="https://cloud.githubusercontent.com/assets/3028125/12213714/5b208976-b632-11e5-8406-38d379ec46aa.png" alt="nvidia-gpu-docker"></p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>The NVIDIA Container Toolkit allows users to build and run GPU accelerated Docker containers. The toolkit includes a container runtime <a target="_blank" rel="noopener" href="https://github.com/NVIDIA/libnvidia-container">library</a> and utilities to automatically configure containers to leverage NVIDIA GPUs. </p>
<p>Product documentation including an architecture overview, platform support, installation and usage guides can be found in the <a target="_blank" rel="noopener" href="https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/overview.html">documentation repository</a>. </p>
<p>Frequently asked questions are available on the <a target="_blank" rel="noopener" href="https://github.com/NVIDIA/nvidia-docker/wiki">wiki</a>.</p>
<h2 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h2><p><a target="_blank" rel="noopener" href="https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/latest/install-guide.html#installing-with-apt">https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/latest/install-guide.html#installing-with-apt</a></p>
<p><strong>Make sure you have installed the <a target="_blank" rel="noopener" href="https://github.com/NVIDIA/nvidia-docker/wiki/Frequently-Asked-Questions#how-do-i-install-the-nvidia-driver">NVIDIA driver</a> and Docker engine for your Linux distribution</strong><br><strong>Note that you do not need to install the CUDA Toolkit on the host system, but the NVIDIA driver needs to be installed</strong></p>
<p>For instructions on getting started with the NVIDIA Container Toolkit, refer to the <a target="_blank" rel="noopener" href="https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/install-guide.html#docker">installation guide</a>. </p>
<p>Installing with Apt<br>Configure the repository:</p>
<p>curl -fsSL <a target="_blank" rel="noopener" href="https://nvidia.github.io/libnvidia-container/gpgkey">https://nvidia.github.io/libnvidia-container/gpgkey</a> | sudo gpg –dearmor -o &#x2F;usr&#x2F;share&#x2F;keyrings&#x2F;nvidia-container-toolkit-keyring.gpg <br>  &amp;&amp; curl -s -L <a target="_blank" rel="noopener" href="https://nvidia.github.io/libnvidia-container/stable/deb/nvidia-container-toolkit.list">https://nvidia.github.io/libnvidia-container/stable/deb/nvidia-container-toolkit.list</a> | <br>    sed ‘s#deb https:&#x2F;&#x2F;#deb [signed-by&#x3D;&#x2F;usr&#x2F;share&#x2F;keyrings&#x2F;nvidia-container-toolkit-keyring.gpg] https:&#x2F;&#x2F;#g’ | <br>    sudo tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;nvidia-container-toolkit.list</p>
<p>sudo apt-get update<br>sudo apt-get install -y nvidia-container-toolkit</p>
<h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><p>The <a target="_blank" rel="noopener" href="https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/user-guide.html">user guide</a> provides information on the configuration and command line options available when running GPU containers with Docker. </p>
<p>Docker 使用容器创建虚拟环境，以便将 TensorFlow 安装结果与系统的其余部分隔离开来。TensorFlow 程序在此虚拟环境中运行，该环境能够与其主机共享资源（访问目录、使用 GPU、连接到互联网等）。我们会针对每个版本测试 TensorFlow Docker 映像。</p>
<p>Docker 是在 Linux 上启用 TensorFlow GPU 支持的最简单方法，因为只需在主机上安装 NVIDIA® GPU 驱动程序，而不必安装 NVIDIA® CUDA® 工具包。</p>
<p>TensorFlow Docker 要求<br>在本地主机上安装 Docker。<br>如需在 Linux 上启用 GPU 支持，请安装 NVIDIA Docker 支持。<a target="_blank" rel="noopener" href="https://github.com/NVIDIA/nvidia-docker">https://github.com/NVIDIA/nvidia-docker</a><br>请通过 docker -v 检查 Docker 版本。对于 19.03 之前的版本，您需要使用 nvidia-docker2 和 –runtime&#x3D;nvidia 标记；对于 19.03 及之后的版本，您将需要使用 nvidia-container-toolkit 软件包和 –gpus all 标记。这两个选项都记录在上面链接的网页上。</p>
<p>sudo docker run –gpus all –rm nvidia&#x2F;cuda nvidia-smi</p>
<h1 id="remove-删除docker-push-registry的镜像"><a href="#remove-删除docker-push-registry的镜像" class="headerlink" title="remove 删除docker push registry的镜像"></a>remove 删除docker push registry的镜像</h1><p>直接删除仓库容器&#x2F;var&#x2F;lib&#x2F;registry&#x2F;docker&#x2F;registry&#x2F;v2&#x2F;repositories&#x2F;下面的镜像目录。<br>sudo docker exec -it registry sh<br>docker exec registry rm -rf &#x2F;var&#x2F;lib&#x2F;registry&#x2F;docker&#x2F;registry&#x2F;v2&#x2F;repositories&#x2F;centos<br>or<br>或者可以将这个目录通过volume映射到宿主机上面来，这样便于管理。<br>rm -rf &#x2F;data&#x2F;docker.registry&#x2F;var&#x2F;lib&#x2F;registry&#x2F;docker&#x2F;registry&#x2F;v2&#x2F;repositories&#x2F;centos</p>
<p>垃圾回收<br>docker exec registry &#x2F;bin&#x2F;registry garbage-collect &#x2F;etc&#x2F;docker&#x2F;registry&#x2F;config.yml<br>&#x2F;bin&#x2F;registry garbage-collect &#x2F;etc&#x2F;docker&#x2F;registry&#x2F;config.yml<br>sudo docker restart registry<br>curl ‘<a target="_blank" rel="noopener" href="https://registry.tongfu.net:5000/v2/_catalog">https://registry.tongfu.net:5000/v2/_catalog</a>‘</p>
<h1 id="Start-a-docker-registry"><a href="#Start-a-docker-registry" class="headerlink" title="Start a docker registry"></a>Start a docker registry</h1><p>$ docker run -d -p 5000:5000 –restart&#x3D;always –name registry registry:2</p>
<h1 id="Push-local-docker-container-to-it"><a href="#Push-local-docker-container-to-it" class="headerlink" title="Push local docker container to it"></a>Push local docker container to it</h1><p>$ docker tag alpine localhost:5000&#x2F;alpine<br>$ docker push localhost:5000&#x2F;alpine</p>
<h1 id="Create-def-file-for-singularity-like-this"><a href="#Create-def-file-for-singularity-like-this" class="headerlink" title="Create def file for singularity like this.."></a>Create def file for singularity like this..</h1><h1 id="add-your-modifications"><a href="#add-your-modifications" class="headerlink" title="(add your modifications)"></a>(add your modifications)</h1><p>Bootstrap: docker<br>Registry: <a target="_blank" rel="noopener" href="http://localhost:5000/">http://localhost:5000</a><br>Namespace:<br>From: alpine:latest</p>
<h1 id="Build-singularity-container"><a href="#Build-singularity-container" class="headerlink" title="Build singularity container"></a>Build singularity container</h1><p>$ sudo SINGULARITY_NOHTTPS&#x3D;1 singularity build alpine.simg def</p>
<p><a target="_blank" rel="noopener" href="https://github.com/apptainer/singularity/issues/1537">build a singularity image from a local docker image</a></p>
<h2 id="install-docker-on-ubuntu"><a href="#install-docker-on-ubuntu" class="headerlink" title="install docker on ubuntu"></a>install docker on ubuntu</h2><p><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/install/ubuntu/">https://docs.docker.com/engine/install/ubuntu/</a></p>
<p>for pkg in docker.io docker-doc docker-compose docker-compose-v2 podman-docker containerd runc; do sudo apt-get remove $pkg; done</p>
<p>sudo apt-get purge docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin docker-ce-rootless-extras</p>
<p>sudo rm -rf &#x2F;var&#x2F;lib&#x2F;docker<br>sudo rm -rf &#x2F;var&#x2F;lib&#x2F;containerd</p>
<p>Images, containers, volumes, and networks stored in &#x2F;var&#x2F;lib&#x2F;docker&#x2F; aren’t automatically removed when you uninstall Docker. If you want to start with a clean installation, and prefer to clean up any existing data, read the uninstall Docker Engine section.</p>
<h1 id="Add-Docker’s-official-GPG-key"><a href="#Add-Docker’s-official-GPG-key" class="headerlink" title="Add Docker’s official GPG key:"></a>Add Docker’s official GPG key:</h1><p>docker 被墙后安装使用aliyun镜像<br><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000044973692">https://segmentfault.com/a/1190000044973692</a></p>
<p>curl -fsSL <a target="_blank" rel="noopener" href="http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg">http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg</a> | sudo gpg –dearmor -o &#x2F;etc&#x2F;apt&#x2F;keyrings&#x2F;docker.gpg</p>
<p>sudo add-apt-repository “deb [arch&#x3D;amd64] <a target="_blank" rel="noopener" href="http://mirrors.aliyun.com/docker-ce/linux/ubuntu">http://mirrors.aliyun.com/docker-ce/linux/ubuntu</a> $(lsb_release -cs) stable”</p>
<p>sudo apt-get update;<br>sudo apt-get install ca-certificates curl gnupg;<br>sudo install -m 0755 -d &#x2F;etc&#x2F;apt&#x2F;keyrings<br>curl -fsSL <a target="_blank" rel="noopener" href="https://download.docker.com/linux/ubuntu/gpg">https://download.docker.com/linux/ubuntu/gpg</a> | sudo gpg –dearmor -o &#x2F;etc&#x2F;apt&#x2F;keyrings&#x2F;docker.gpg<br>sudo chmod a+r &#x2F;etc&#x2F;apt&#x2F;keyrings&#x2F;docker.gpg</p>
<h1 id="Add-the-repository-to-Apt-sources"><a href="#Add-the-repository-to-Apt-sources" class="headerlink" title="Add the repository to Apt sources:"></a>Add the repository to Apt sources:</h1><p>echo <br>  “deb [arch&#x3D;$(dpkg –print-architecture) signed-by&#x3D;&#x2F;etc&#x2F;apt&#x2F;keyrings&#x2F;docker.gpg] <a target="_blank" rel="noopener" href="https://download.docker.com/linux/ubuntu">https://download.docker.com/linux/ubuntu</a> <br>  $(. &#x2F;etc&#x2F;os-release &amp;&amp; echo “$VERSION_CODENAME”) stable” | <br>  sudo tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;docker.list &gt; &#x2F;dev&#x2F;null<br>sudo apt-get update</p>
<p>sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</p>
<p>sudo docker run hello-world</p>
<p>sudo apt-get install docker-compose-plugin</p>
<p>sudo apt-get update<br>sudo apt-get install docker-compose-plugin</p>
<h1 id="On-the-host-where-you-run-docker-find-the-image-ID-of-the-docker-image-you-want-to-convert"><a href="#On-the-host-where-you-run-docker-find-the-image-ID-of-the-docker-image-you-want-to-convert" class="headerlink" title="On the host where you run docker, find the image ID of the docker image you want to convert"></a>On the host where you run docker, find the image ID of the docker image you want to convert</h1><p>docker images</p>
<h1 id="Save-the-docker-image-as-a-tarball-e-g-lolcow-tar"><a href="#Save-the-docker-image-as-a-tarball-e-g-lolcow-tar" class="headerlink" title="Save the docker image as a tarball, e.g. lolcow.tar"></a>Save the docker image as a tarball, e.g. lolcow.tar</h1><p>docker save image_id -o lolcow.tar</p>
<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>docker-compose pull &amp;&amp; docker-compose restart<br>port &#x3D; 8088</p>
<p>如果你有一个本地的 Docker 镜像，你想要将它分享给其他的计算机，你可以按照以下的步骤操作：</p>
<ol>
<li>首先，你需要将你的 Docker 镜像保存为一个 tar 文件。你可以使用 <code>docker save</code> 命令来做这个：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o &lt;path <span class="keyword">for</span> generated tar file&gt; &lt;image name&gt;</span><br></pre></td></tr></table></figure>

<p>例如，如果你的镜像名为 <code>my_image</code>，你可以运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o my_image.tar my_image</span><br></pre></td></tr></table></figure>

<p>这个命令将会创建一个名为 <code>my_image.tar</code> 的文件，这个文件包含了 <code>my_image</code> 镜像的所有层和元数据。</p>
<ol start="2">
<li><p>然后，你可以将这个 tar 文件复制到其他的计算机上。你可以使用任何你喜欢的方法来做这个，例如，使用 USB 驱动器，或者通过网络传输。</p>
</li>
<li><p>在其他的计算机上，你可以使用 <code>docker load</code> 命令来从 tar 文件中加载 Docker 镜像：</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i &lt;path to tar file&gt;</span><br></pre></td></tr></table></figure>

<p>例如，你可以运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i my_image.tar</span><br></pre></td></tr></table></figure>

<p>这个命令将会从 <code>my_image.tar</code> 文件中加载 Docker 镜像。</p>
<p>现在，你应该可以在其他的计算机上使用你的 Docker 镜像了。你可以使用 <code>docker images</code> 命令来确认镜像已经被正确地加载。</p>
<h1 id="http-server-gave-HTTP-response-to-HTTPS-client"><a href="#http-server-gave-HTTP-response-to-HTTPS-client" class="headerlink" title="http: server gave HTTP response to HTTPS client"></a>http: server gave HTTP response to HTTPS client</h1><p>这个错误通常发生在尝试将 Docker 镜像推送到没有配置 HTTPS 的 Docker registry 时。默认情况下，Docker 客户端需要使用 HTTPS 来与 Docker registry 通信。如果 Docker registry 没有配置 HTTPS，Docker 客户端会拒绝与它通信，并显示这个错误。</p>
<p>要解决这个问题，你有两个选择：</p>
<ol>
<li><p><strong>配置 Docker registry 使用 HTTPS</strong>：这是推荐的解决方案，因为 HTTPS 可以保护你的 Docker 镜像在传输过程中的安全。</p>
</li>
<li><p><strong>配置 Docker 客户端允许使用 HTTP 与 Docker registry 通信</strong>：这个解决方案的安全性较低，因为 HTTP 不是一个安全的协议。然而，如果你只是在本地网络中使用 Docker registry，或者你的 Docker 镜像不包含敏感信息，你可能会选择这个解决方案。要配置 Docker 客户端允许使用 HTTP，你需要编辑 Docker 守护进程的配置文件（通常是 <code>/etc/docker/daemon.json</code>），并添加以下内容：</p>
</li>
</ol>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;https://docker.m.daocloud.io&quot;</span><span class="punctuation">,</span><span class="string">&quot;https://docker.1panel.live&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;insecure-registries&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;myregistry:5000&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<p>在这个配置中，<code>myregistry:5000</code> 是你的 Docker registry 的地址。你应该将它替换为你的 Docker registry 的实际地址。添加完成后，你需要重启 Docker 守护进程以使这个配置生效。</p>
<h1 id="install-singularity"><a href="#install-singularity" class="headerlink" title="install singularity"></a>install singularity</h1><p>sudo apt-get update &amp;&amp; sudo apt-get install -y autoconf automake cryptsetup git libfuse-dev libglib2.0-dev libseccomp-dev libtool pkg-config runc squashfs-tools squashfs-tools-ng uidmap wget zlib1g-dev make;</p>
<p><code>make</code> 和 <code>make-guile</code> 都是 GNU Make 的版本，但它们的功能有所不同。</p>
<p><code>make</code> 是一个工具，它可以自动决定哪些部分的大型程序需要被重新编译，并发出命令来重新编译它们。它使用名为 <code>Makefile</code> 的文件来确定哪些文件需要被重新编译。</p>
<p><code>make-guile</code> 是 GNU Make 的一个版本，它包含了对 GNU Guile 的支持。GNU Guile 是一个嵌入式的 Scheme 编程语言，它可以用来扩展支持 Guile 的程序。在 <code>make-guile</code> 中，你可以使用 Guile 作为一个替代 Makefile 的传统语法的脚本语言。这可以让你编写更复杂的构建规则，并利用 Guile 提供的高级编程特性。</p>
<p>总的来说，如果你只需要基本的构建功能，你可能只需要 <code>make</code>。如果你需要更复杂的构建规则，或者你想要使用 Scheme 语言来编写你的构建规则，你可能需要 <code>make-guile</code>。</p>
<p>export VERSION&#x3D;1.21.4 OS&#x3D;linux ARCH&#x3D;amd64 &amp;&amp; wget <a target="_blank" rel="noopener" href="https://dl.google.com/go/go$VERSION.$OS-$ARCH.tar.gz">https://dl.google.com/go/go$VERSION.$OS-$ARCH.tar.gz</a> &amp;&amp; sudo tar -C &#x2F;usr&#x2F;local -xzvf go$VERSION.$OS-$ARCH.tar.gz &amp;&amp; rm go$VERSION.$OS-$ARCH.tar.gz;</p>
<p>export VERSION&#x3D;1.21.6 OS&#x3D;linux ARCH&#x3D;amd64 &amp;&amp; wget <a target="_blank" rel="noopener" href="https://dl.google.com/go/go$VERSION.$OS-$ARCH.tar.gz">https://dl.google.com/go/go$VERSION.$OS-$ARCH.tar.gz</a> &amp;&amp; sudo tar -C &#x2F;usr&#x2F;local -xzvf go$VERSION.$OS-$ARCH.tar.gz &amp;&amp; rm go$VERSION.$OS-$ARCH.tar.gz</p>
<p>echo ‘export PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;go&#x2F;bin:$PATH’ &gt;&gt; ~&#x2F;.bashrc &amp;&amp; source ~&#x2F;.bashrc;</p>
<p>export VERSION&#x3D;4.0.2 &amp;&amp; wget <a target="_blank" rel="noopener" href="https://github.com/sylabs/singularity/releases/download/v$%7BVERSION%7D/singularity-ce-$%7BVERSION%7D.tar.gz">https://github.com/sylabs/singularity/releases/download/v${VERSION}/singularity-ce-${VERSION}.tar.gz</a> &amp;&amp; tar -xzf singularity-ce-${VERSION}.tar.gz &amp;&amp; cd singularity-ce-${VERSION};</p>
<p>export VERSION&#x3D;4.1.0 &amp;&amp; wget <a target="_blank" rel="noopener" href="https://github.com/sylabs/singularity/releases/download/v$%7BVERSION%7D/singularity-ce-$%7BVERSION%7D.tar.gz">https://github.com/sylabs/singularity/releases/download/v${VERSION}/singularity-ce-${VERSION}.tar.gz</a> &amp;&amp; tar -xzf singularity-ce-${VERSION}.tar.gz &amp;&amp; cd singularity-ce-${VERSION}</p>
<p> .&#x2F;mconfig &amp;&amp; make -C builddir &amp;&amp; sudo make -C builddir install;</p>
<h1 id="singularity-with-nvidia-–nv"><a href="#singularity-with-nvidia-–nv" class="headerlink" title="singularity with nvidia –nv"></a>singularity with nvidia –nv</h1><p>singularity build lolcow.sif docker:&#x2F;&#x2F;godlovedc&#x2F;lolcow<br>singularity build -s –nv vasp_gpu docker:&#x2F;&#x2F;127.0.0.1:5000&#x2F;vasp_gpu:12.3.86</p>
<h1 id="清理-singularity-缓存"><a href="#清理-singularity-缓存" class="headerlink" title="清理 singularity 缓存"></a>清理 singularity 缓存</h1><p>singularity cache clean –dry-run<br>singularity cache clean</p>
<h1 id="将新硬盘内容移到Linux机器"><a href="#将新硬盘内容移到Linux机器" class="headerlink" title="将新硬盘内容移到Linux机器"></a>将新硬盘内容移到Linux机器</h1><p>在 Linux 中，将一个硬盘接入并将其内容移到其他硬盘的步骤如下：<br>sudo fdisk -l<br>sudo mkdir &#x2F;mnt&#x2F;mydisk<br>sudo mount &#x2F;dev&#x2F;sda2 &#x2F;mnt&#x2F;mydisk<br>sudo cp -R &#x2F;mnt&#x2F;mydisk&#x2F;* &#x2F;path&#x2F;to&#x2F;other&#x2F;disk<br>sudo umount &#x2F;mnt&#x2F;mydisk</p>
<p>how to deal with “Failed to initialize NVML: Driver&#x2F;library version mismatch NVML library version: 535.146” in ubuntu?</p>
<p>这个错误表示你的NVIDIA驱动和NVML库版本不匹配。你可以尝试以下步骤来解决这个问题：</p>
<ol>
<li>首先，卸载当前的NVIDIA驱动：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove --purge nvidia-*</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>然后，更新你的系统：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update &amp;&amp; sudo apt-get upgrade</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>重新安装NVIDIA驱动。你可以从NVIDIA官网下载最新的驱动，或者使用<code>ubuntu-drivers</code>命令自动安装推荐的驱动：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ubuntu-drivers autoinstall</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>重启你的系统：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo reboot</span><br></pre></td></tr></table></figure>

<p>这些步骤应该可以解决驱动和库版本不匹配的问题。如果问题仍然存在，你可能需要检查你的硬件是否与新的驱动版本兼容，或者尝试安装不同版本的驱动。</p>
<h1 id="adduser和deluser命令"><a href="#adduser和deluser命令" class="headerlink" title="adduser和deluser命令"></a>adduser和deluser命令</h1><p>在Ubuntu中，你可以使用<code>adduser</code>和<code>deluser</code>命令来添加和删除用户账户。</p>
<p>添加用户账户：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo adduser newusername</span><br><span class="line">sudo adduser jjcainew</span><br><span class="line">jjcai*18623716021</span><br></pre></td></tr></table></figure>

<p>在 Ubuntu 中创建用户账户通常涉及使用 <code>adduser</code> 或 <code>useradd</code> 命令。<code>adduser</code> 是更为友好的前端，它在 <code>useradd</code> 的基础上提供了更多的交互式选项，包括为新用户设置密码和创建家目录等。以下是使用 <code>adduser</code> 命令创建新用户账户的步骤：</p>
<ol>
<li><p>打开终端。</p>
</li>
<li><p>输入以下命令来创建一个新的用户账户（将 <code>username</code> 替换为你想要的用户名）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo adduser username</span><br><span class="line">sudo adduser jjcainew</span><br></pre></td></tr></table></figure>
<p>这个命令会提示你输入新用户的密码以及一些额外的信息（如全名、电话号码等），这些信息是可选的，可以直接按回车跳过。</p>
</li>
<li><p>如果需要，你还可以将新用户添加到额外的用户组中。例如，要将用户添加到 <code>sudo</code> 组以允许其执行 <code>sudo</code> 命令，可以使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG sudo username</span><br></pre></td></tr></table></figure>
<p>这里 <code>-aG</code> 选项表示将用户添加到一个或多个额外的组中。</p>
</li>
</ol>
<p>完成这些步骤后，就成功创建了一个新的用户账户，并且根据需要，该用户可以使用 <code>sudo</code> 命令来执行需要超级用户权限的操作。</p>
<p>请注意，根据你的系统配置和安全策略，可能需要管理员权限来创建新用户。此外，确保选择一个强密码来增加账户的安全性。</p>
<p>这个命令会创建一个新的用户<code>newusername</code>，并且会创建一个同名的用户主目录。系统会提示你输入新用户的密码和一些其他信息。</p>
<p>删除用户账户：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo deluser username</span><br></pre></td></tr></table></figure>

<p>这个命令会删除用户<code>username</code>。请注意，这个命令不会删除用户的主目录。如果你想删除用户的主目录，你可以使用<code>--remove-home</code>选项：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo deluser --remove-home username</span><br></pre></td></tr></table></figure>

<p>请注意，添加和删除用户账户需要管理员权限。</p>
<h1 id="bash-shell的执行顺序如下："><a href="#bash-shell的执行顺序如下：" class="headerlink" title="bash shell的执行顺序如下："></a>bash shell的执行顺序如下：</h1><ol>
<li><p><code>/etc/profile</code>: 这个文件是系统级别的配置文件，对所有用户有效。通常在这个文件中设置全局环境变量。</p>
</li>
<li><p><code>/etc/profile.d/</code>: 这个目录下的所有.sh文件都会被执行。这些文件通常由各种软件包提供，用于设置环境变量。</p>
</li>
<li><p><code>~/.bash_profile</code> 或 <code>~/.profile</code>：这两个文件只对当前用户有效。如果<code>~/.bash_profile</code>存在，那么它会被执行。否则，<code>~/.profile</code>会被执行。通常在这个文件中设置用户级别的环境变量和启动程序。</p>
</li>
<li><p><code>~/.bashrc</code>: 这个文件也只对当前用户有效。它在每个非登录shell（例如新开的终端窗口）中都会被执行。通常在这个文件中设置别名和函数。</p>
</li>
<li><p><code>/etc/bash.bashrc</code>: 这个文件是系统级别的配置文件，对所有用户有效。它在每个非登录shell中都会被执行。通常在这个文件中设置全局别名和函数。</p>
</li>
</ol>
<p>请注意，这个顺序可能会根据具体的系统配置有所不同。</p>
<h1 id="is-enabled"><a href="#is-enabled" class="headerlink" title="is-enabled"></a>is-enabled</h1><p>在Linux中，你可以使用<code>systemctl</code>命令来检查一个服务是否在启动时运行。以下是具体步骤：</p>
<ol>
<li><p>打开一个终端。</p>
</li>
<li><p>输入以下命令，其中<code>your_service</code>是你要检查的服务的名称：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl is-enabled your_service</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这个命令会返回<code>enabled</code>或<code>disabled</code>。如果返回<code>enabled</code>，那么这个服务会在启动时运行。如果返回<code>disabled</code>，那么这个服务不会在启动时运行。</p>
<p>注意，这个命令需要root权限，所以你可能需要使用<code>sudo</code>，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl is-enabled your_service</span><br></pre></td></tr></table></figure>

<h1 id="shell-中单引号和双引号的区别"><a href="#shell-中单引号和双引号的区别" class="headerlink" title="shell 中单引号和双引号的区别"></a>shell 中单引号和双引号的区别</h1><p>在 Shell 脚本中，单引号（’）和双引号（”）有着不同的行为：</p>
<ul>
<li><strong>单引号</strong>：在单引号中的内容会被视为纯文本字符串，不会进行任何变量替换或命令执行。例如：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var=<span class="string">&#x27;world&#x27;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;Hello, $var&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上述代码将输出 <code>Hello, $var</code>，而不是 <code>Hello, world</code>。</p>
<ul>
<li><strong>双引号</strong>：在双引号中的内容会进行变量替换和命令执行。例如：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var=<span class="string">&#x27;world&#x27;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello, <span class="variable">$var</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>上述代码将输出 <code>Hello, world</code>。</p>
<p>总结一下，如果你想要在字符串中包含变量或命令，你应该使用双引号。如果你想要字符串被视为纯文本，你应该使用单引号。</p>
<h1 id="如何知道服务器cpu是否开启了超线程？"><a href="#如何知道服务器cpu是否开启了超线程？" class="headerlink" title="如何知道服务器cpu是否开启了超线程？"></a>如何知道服务器cpu是否开启了超线程？</h1><p>在 Linux 系统中，你可以通过查看 <code>/proc/cpuinfo</code> 文件来确定是否启用了超线程。你可以使用 <code>grep</code> 命令来查找相关信息。</p>
<p>以下是一个简单的命令，它计算物理 CPU 核心的数量和逻辑 CPU 核心的数量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&#x27;cpu cores&#x27;</span> /proc/cpuinfo | <span class="built_in">uniq</span></span><br><span class="line">grep <span class="string">&#x27;processor&#x27;</span> /proc/cpuinfo | <span class="built_in">wc</span> -l</span><br></pre></td></tr></table></figure>

<p>第一个命令会显示每个物理 CPU 的核心数量，第二个命令会显示逻辑 CPU 的数量（包括超线程）。</p>
<p>如果逻辑 CPU 的数量大于物理 CPU 核心的数量，那么超线程可能已经启用。如果两者相等，那么超线程可能已经禁用。</p>
<p>请注意，这只是一个简单的检查，它可能不适用于所有系统。如果你需要更准确的信息，你应该查看你的系统文档，或者联系你的系统管理员。</p>
<h1 id="sudo-apt-update-error"><a href="#sudo-apt-update-error" class="headerlink" title="sudo apt update error"></a>sudo apt update error</h1><p>Reading package lists… Done<br>E: Could not get lock &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;lock. It is held by process 245016 (apt-get)<br>N: Be aware that removing the lock file is not a solution and may break your system.<br>E: Unable to lock directory &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;</p>
<p>这个错误表明另一个进程正在使用 apt 包管理器。这可能是因为另一个 apt-get 命令正在运行，或者系统正在进行自动更新。</p>
<p>首先，你可以尝试等待一段时间，看看是否有其他进程正在使用 apt。如果等待一段时间后问题仍然存在，你可以尝试以下步骤：</p>
<ol>
<li>查找正在使用 apt 的进程：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep apt</span><br></pre></td></tr></table></figure>

<p>这将列出所有正在运行的与 apt 相关的进程。你可以查找进程 ID 为 245016 的进程，看看它是什么。</p>
<ol start="2">
<li>如果你确定这个进程已经不再需要，或者它已经卡住不动了，你可以使用以下命令杀掉它：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">kill</span> -9 245016</span><br></pre></td></tr></table></figure>

<p>然后你应该能够再次运行 apt-get 命令。</p>
<p>注意：强制杀掉 apt 进程可能会导致包管理器处于不一致的状态。在大多数情况下，这不会造成问题，但在某些情况下，可能需要手动修复。</p>
<h1 id="mpirun-v-s-mpiexec"><a href="#mpirun-v-s-mpiexec" class="headerlink" title="mpirun v.s. mpiexec"></a>mpirun v.s. mpiexec</h1><p><code>mpirun</code>和<code>mpiexec</code>都是用于启动MPI（Message Passing Interface）程序的命令。它们的主要区别在于它们遵循的标准和一些特性。</p>
<ol>
<li><p><code>mpirun</code>：这是一个传统的命令，用于启动MPI程序。它是Open MPI和一些其他MPI实现的一部分。<code>mpirun</code>提供了一些有用的特性，如动态进程管理和资源发现。然而，<code>mpirun</code>并不遵循任何特定的标准，因此它的行为可能会因不同的MPI实现而异。</p>
</li>
<li><p><code>mpiexec</code>：这是一个遵循MPI-2和MPI-3标准的命令，用于启动MPI程序。<code>mpiexec</code>的行为和参数在所有遵循这些标准的MPI实现中都是一致的。然而，<code>mpiexec</code>可能不支持<code>mpirun</code>的一些特性，如动态进程管理。</p>
</li>
</ol>
<p>总的来说，如果你的MPI程序需要特定的<code>mpirun</code>特性，或者你正在使用的MPI实现推荐使用<code>mpirun</code>，那么你应该使用<code>mpirun</code>。否则，为了保证可移植性，你应该使用<code>mpiexec</code>。</p>
<h1 id="neofetch"><a href="#neofetch" class="headerlink" title="neofetch"></a>neofetch</h1><p>Neofetch 是一个命令行工具，它可以显示关于你的系统的信息，包括操作系统、主机名、内核、Uptime、窗口管理器、Shell、分辨率、主题、图标、CPU、GPU 和 RAM 等。它还可以显示你的电脑的 logo。</p>
<p>Neofetch 非常灵活，你可以配置它显示哪些信息，以及如何显示这些信息。它支持多种操作系统，包括 Linux、OS X、iOS、BSD 和 Windows 等。</p>
<p>要在 Ubuntu 中安装 Neofetch，你可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install neofetch</span><br></pre></td></tr></table></figure>

<p>安装完成后，你可以通过在终端中输入 <code>neofetch</code> 来运行它：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">neofetch</span><br></pre></td></tr></table></figure>

<p><img src="/image.png" alt="alt text"></p>
<h1 id="linux-service-daemon"><a href="#linux-service-daemon" class="headerlink" title="linux service daemon"></a>linux service daemon</h1><p>[Unit]<br>Description&#x3D;My Daemon</p>
<p>[Service]<br>ExecStart&#x3D;&#x2F;path&#x2F;to&#x2F;your&#x2F;daemon<br>Restart&#x3D;always<br>User&#x3D;root<br>Group&#x3D;root<br>Environment&#x3D;PATH&#x3D;&#x2F;usr&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;bin<br>EnvironmentFile&#x3D;-&#x2F;etc&#x2F;default&#x2F;mydaemon</p>
<p>EnvironmentFile&#x3D;-&#x2F;etc&#x2F;default&#x2F;ssh<br>ExecStartPre&#x3D;&#x2F;usr&#x2F;sbin&#x2F;sshd -t<br>ExecStart&#x3D;&#x2F;usr&#x2F;sbin&#x2F;sshd -D $SSHD_OPTS<br>ExecReload&#x3D;&#x2F;usr&#x2F;sbin&#x2F;sshd -t<br>ExecReload&#x3D;&#x2F;bin&#x2F;kill -HUP $MAINPID<br>KillMode&#x3D;process<br>Restart&#x3D;on-failure<br>RestartPreventExitStatus&#x3D;255<br>Type&#x3D;notify<br>RuntimeDirectory&#x3D;sshd<br>RuntimeDirectoryMode&#x3D;0755</p>
<p>[Install]<br>WantedBy&#x3D;multi-user.target</p>
<p>在Linux系统中，systemctl是Systemd的主命令行工具，用于控制Systemd系统和服务管理器。通过使用systemctl，您可以添加、删除、启用和禁用自定义系统服务。下面是如何使用systemctl添加自定义系统服务的步骤：</p>
<p>创建服务文件：首先，您需要创建一个服务文件，用于描述自定义服务的配置。服务文件的扩展名为.service，并放置在&#x2F;etc&#x2F;systemd&#x2F;system目录下。例如，如果您要添加名为mycustomservice的自定义服务，可以创建一个名为mycustomservice.service的文件。<br>使用文本编辑器打开mycustomservice.service文件，并添加以下内容作为示例：</p>
<p>在上述示例中，您需要将ExecStart选项的值替换为您实际要执行的脚本或可执行文件的路径。<br>编写脚本：在创建服务文件之前，您需要编写一个启动脚本，该脚本将在启动服务时执行。在示例中，您需要创建一个名为script.sh的脚本文件，并将其放置在&#x2F;path&#x2F;to&#x2F;your&#x2F;目录下。确保该脚本具有可执行权限。<br>启动服务：完成服务文件和启动脚本的创建后，您可以使用以下命令启动自定义服务：<br>sudo systemctl start mycustomservice<br>如果您希望在系统启动时自动启动该服务，请使用以下命令启用服务：<br>sudo systemctl enable mycustomservice<br>查看服务状态：要检查自定义服务的状态，请使用以下命令：<br>sudo systemctl status mycustomservice<br>这将显示有关服务当前状态的信息，包括是否正在运行以及任何相关的日志输出。<br>管理服务：您可以使用systemctl命令进行各种服务管理操作，例如停止、重新启动和重新加载服务。例如：<br>sudo systemctl stop mycustomservice  # 停止服务<br>sudo systemctl restart mycustomservice  # 重新启动服务<br>sudo systemctl reload mycustomservice  # 重新加载服务配置<br>这些是使用systemctl添加自定义系统服务的基本步骤。通过创建自定义服务文件并编写适当的启动脚本，您可以灵活地控制和管理您的Linux系统中的服务。请记住，在使用systemctl之前，您需要具有适当的系统权限（通常为root用户或使用sudo命令）。</p>
<h2 id="第一节-简介"><a href="#第一节-简介" class="headerlink" title="第一节:简介"></a>第一节:简介</h2><p>开机第一个程序从init完全换成了systemd这种启动方式。systemd是靠管理unit的方式来控制开机服务，开机级别等功能。在&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system目录下包含了各种unit文件，有service后缀的服务unit，有target后缀的开机级别unit等，这里介绍关于service后缀的文件。因为systemd在开机要想执行自启动，都是通过这些.service 的unit控制的，服务又分为系统服务 (system) 和用户服务 (user)。系统服务: 开机不登陆就能运行的程序(常用于开机自启)。用户服务:需要登陆以后才能运行的程序</p>
<h2 id="第二节-serivces配置文件说明"><a href="#第二节-serivces配置文件说明" class="headerlink" title="第二节: serivces配置文件说明:"></a>第二节: serivces配置文件说明:</h2><p>[Unit] 区块: 启动顺序与依赖关系<br>Description字段: 给出当前服务的简单描述。<br>Documentation字段: 给出文档位置。<br>After字段: 如果network.target或sshd-keygen.service需要启动，那么sshd.service应该在它们之后启动。<br>Before字段: 定义sshd.service应该在哪些服务之前启动<br>注: After和Before字段只涉及启动顺序，不涉及依赖关系<br>举例来说，某 Web 应用需要 postgresql 数据库储存数据。在配置文件中，它只定义要在postgresql 之后启动，而没有定义依赖 postgresql 。上线后，由于某种原因，postgresgl 需要重新启动，在停止服务期间，该 Web 应用就会无法建立数据库连接设置依赖关系，重要使用Wants字段和Requires字段。<br>Wants字段: 表示sshd.service与sshd-keygen.service之间存在”弱依赖”关系，即如果”sshd.keygen.service”启动失败或停止运行，不影响sshd.service继续执行。<br>Requires字段则表示”强依赖”关系，即如果该服务启动失败或异常退出，那么sshd.service也必须退出。<br>注意，Wants字段与Requires字段只涉及依赖关系，与启动顺序无关，默认情况下是同时启动的。<br>[Service] 区块: 启动行为</p>
<h3 id="启动命令"><a href="#启动命令" class="headerlink" title="启动命令"></a>启动命令</h3><p>ExecStart字段: 定义启动进程时执行的命令<br>ExecReload字段: 重启服务时执行的命令<br>ExecStop字段: 停止服务时执行的命令<br>ExecStartPre字段: 启动服务之前执行的命令<br>ExecStartPost字段: 启动服务之后执行的命令<br>ExecstopPost字段: 停止服务之后执行的命念<br>注: 所有的启动设置之前，都可以加上一个连词号 ()，表示”抑制错误”，即发生错误的时候，不影响其他命令的执行。比如EnvironmentFile&#x3D;-&#x2F;etc&#x2F;sysconfig&#x2F;sshd (注意等号后面的那个连词号)，就表示即使&#x2F;etc&#x2F;sysconfig&#x2F;sshd文件不存在，也不会抛出错误。<br>注意:[Service]中的启动、重启、停止命令全部要求使用绝对路径!</p>
<h3 id="启动类型"><a href="#启动类型" class="headerlink" title="启动类型"></a>启动类型</h3><p>Type字段定义启动类型。它可以设置的值如下:<br>simple (默认值): ExecStart字段启动的进程为主进程<br>forking: ExecStart字段将以fork()方式启动，此时父进程将会退出，子进程将成为主进程(后台运行)<br>oneshot: 类似于simple，但只执行一次，Systemd 会等它执行完，才启动其他服务<br>dbus: 类似于simple，但会等待 D-Bus 信号后启动<br>notify: 类似于simple，启动结束后会发出通知信号，然后 Systemd 再启动其他服务<br>idle: 类似于simple，但是要等到其他任务都执行完，才会启动该服务。一种使用场合是为让该服务的输出，不与其他服务的输出相混合</p>
<h3 id="重启行为"><a href="#重启行为" class="headerlink" title="重启行为"></a>重启行为</h3><p>Service区块有一些字段，定义了重启行为:<br>KillMode字段: 定义 Systemd 如何停止 sshd 服务:<br>control-group (默认值) : 当前控制组里面的所有子进程，都会被杀掉<br>process: 只杀主讲程<br>mixed: 主进程将收到 SIGTERM 信号，子进程收到 SIGKILL 信号<br>none: 没有进程会被杀掉，只是执行服务的 stop 命令。<br>Restart字段: 定义了 sshd 退出后，Systemd 的重启方式<br>上面的例子中，Restart设为on-failure，表示任何意外的失败，就将重启sshd。如果 sshd正常停止(比如执行systemctl stop命令)，它就不会重启。<br>Restart字段可以设置的值如下。<br>no (默认值) : 退出后不会重启<br>on-success: 只有正常退出时 (退出状态码为0)，才会重启<br>on-failure: 非正常退出时(退出状态码非0)，包括被信号终止和超时，才会重启<br>on-abnormal: 只有被信号终止和超时，才会重启<br>on-abort: 只有在收到没有捕捉到的信号终止时，才会重启<br>on-watchdog: 超时退出，才会重启<br>always: 不管是什么退出原因，总是重启<br>注: 对于守护进程，推荐设为on-failure。对于那些允许发生错误退出的服务，可以设为on-abnormal.<br>RestartSec字段: 表示 Svstemd 重启服务之前，需要等待的秒数<br>上面的例子设为等待42秒</p>
<p>[Install] 区块<br>install区块，定义如何安装这个配置文件，即怎样做到开机启动<br>WantedBy字段: 表示该服务所在的 Target。<br>Target的含义是服务组，表示一组服务。<br>WantedBy&#x3D;multi-user.target指的是: sshd 所在的 Target 是multi-user.target。<br>这个设置非常重要，因为执行systemctl enable sshd.service命令时，sshd.service的一个符号链接，就会放在&#x2F;etc&#x2F;systemd&#x2F;system目录下面的multi-user.target.wants子目录之中。<br>Systemd 有默认的启动 Target.</p>
<p>systemctl get-default<br>#输出multi-user.target<br>上面的结果表示，默认的启动 Target 是multi-user.target。在这个组里的所有服务，都将开机启<br>动。这就是为什么systemctl enable命令能设置开机启动的原因。<br>使用 Target 的时候，systemctl list-dependencies命令和systemctl isolate命令也很有用.</p>
<p>#查看 multi-user.taraet 包含的所有服务<br>systemctl list-dependencies multi-user.target</p>
<p>#切换到另一个 target</p>
<p>#shutdown.target 就是关机状态<br>systemctl isolate shutdown .target</p>
<p>一般来说，常用的 Target 有两个:<br>multi-user.target: 表示多用户命令行状态;<br>graphical.target: 表示图形用户状态，它依赖于multi-user.target</p>
<h2 id="第三节-注册服务实例介绍"><a href="#第三节-注册服务实例介绍" class="headerlink" title="第三节: 注册服务实例介绍"></a>第三节: 注册服务实例介绍</h2><p>配置文件目录<br>systemctl脚本目录: &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;<br>系统服务目录: &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system<br>用户服务目录: &#x2F;usr&#x2F;1ib&#x2F;systemd&#x2F;user&#x2F;<br>在&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system目录下新建service-name.service文件:</p>
<p>[UNIT]<br>#服务描述<br>Description&#x3D;Media wanager Service<br>#指定了在systemd在执行完那些target之后再启动该服务<br>After&#x3D;network.target</p>
<p>[Service]<br>#定义Service的运行类型，一般是forking(后台运行)<br>Type&#x3D;forking</p>
<p>#定义systemctl startlstoplreload *.service 的执行方法(具体命令需要写绝对路径)<br>#注: ExecStartPre为启动前执行的命令<br>ExecStartPre&#x3D;&#x2F;usr&#x2F;bin&#x2F;test “x$[NETWORKMANAGER]”&#x3D; xyes<br>ExecStart&#x3D;&#x2F;home&#x2F;mobileoa&#x2F;apps&#x2F;shMediaManager.sh -start<br>ExecReload&#x3D;<br>ExecStop&#x3D;&#x2F;home&#x2F;mobileoa&#x2F;apps&#x2F;shMediaManager.sh -stop</p>
<p>#创建私有的内存临时空间<br>PrivateTmp&#x3D;True</p>
<p>[Install]<br>#多用户<br>WantedBy&#x3D;multi-user.target</p>
<p>重载系统服务: systemctl daemon-reload<br>设置开机启动: systemctl enable *.service<br>启动服务: systemctl start *.service<br>停止服务: systemctl stop *.service<br>重户服务: systemctl reload *.service<br>注: 修改完配置文件要重载配置文件。</p>
<h2 id="第四节-使用svstemd管理Altas"><a href="#第四节-使用svstemd管理Altas" class="headerlink" title="第四节: 使用svstemd管理Altas"></a>第四节: 使用svstemd管理Altas</h2><p>atlas的service配置文件:<br>[Unit]<br>Description&#x3D;Atlas - high performance mysql-proxy server<br>After&#x3D;network-online.target remote-fs.target nss-lookup.target<br>Wants&#x3D;network-online.target</p>
<p>[Service]<br>Type&#x3D;forking<br>PIDFile&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql-proxy&#x2F;log&#x2F;test.pid<br>ExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql-proxy&#x2F;bin&#x2F;mysql-proxyd test start<br>ExecStop&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql-proxy&#x2F;bin&#x2F;mysql-proxyd test stop<br>ExecReload&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql-proxy&#x2F;bin&#x2F;mysql-proxyd test restart<br>PrivateTmp&#x3D;true</p>
<p>[Install]<br>WantedBy&#x3D;multi-user.target</p>
<p>systemctl daemon-reload #重载系统服务，即可使用systemd来管理服务</p>
<h2 id="第五节-启动分析"><a href="#第五节-启动分析" class="headerlink" title="第五节 启动分析"></a>第五节 启动分析</h2><p>分析关键耗时<br>systemd-analyze critical-chain</p>
<p>分析每个服务的耗时<br>systemd-analyze blame</p>
<p>将每个服务的耗时输出到图片<br>systemd-analyze plot &gt; boot.svg<br>列出所有开机自动启动的服务<br>systemctl list-unit-files –type&#x3D;servicegrep enabled</p>
<h1 id="jq"><a href="#jq" class="headerlink" title="jq"></a>jq</h1><p>sudo apt install jq</p>
<p><code>jq</code> 是一个轻量级且灵活的命令行 JSON 处理器。它允许你在命令行中解析、过滤、查询和操作 JSON 数据。</p>
<p>以下是一些基本的 <code>jq</code> 用法：</p>
<ol>
<li><p><strong>输出整个 JSON</strong>：<code>jq . file.json</code>。这将会把整个 JSON 数据以美化的形式输出。</p>
</li>
<li><p><strong>读取特定字段</strong>：<code>jq .field file.json</code>。这将会输出 JSON 数据中名为 “field” 的字段的值。</p>
</li>
<li><p><strong>过滤数组元素</strong>：<code>jq &#39;.array[]&#39; file.json</code>。这将会输出 JSON 数据中名为 “array” 的数组的所有元素。</p>
</li>
<li><p><strong>查询嵌套字段</strong>：<code>jq &#39;.field1.field2&#39; file.json</code>。这将会输出 JSON 数据中名为 “field1” 的字段中名为 “field2” 的子字段的值。</p>
</li>
<li><p><strong>管道操作</strong>：<code>jq &#39;.array[] | .field&#39; file.json</code>。这将会输出 JSON 数据中名为 “array” 的数组的所有元素中名为 “field” 的字段的值。</p>
</li>
<li><p><strong>创建新的 JSON</strong>：<code>jq &#39;&#123;field1: .field1, field2: .field2&#125;&#39; file.json</code>。这将会创建一个新的 JSON 对象，包含原 JSON 数据中名为 “field1” 和 “field2” 的字段的值。</p>
</li>
</ol>
<p><code>jq</code> 的功能非常强大，以上只是一些基本的用法。如果你需要进行更复杂的 JSON 处理，我建议查阅 <code>jq</code> 的官方文档或相关教程。</p>
<p>要使用 <code>jq</code> 从头开始创建一个 JSON 文件，你可以使用 <code>-n</code> 选项（表示不从输入读取任何数据），然后提供你想要在新 JSON 文件中包含的数据。例如，如果你想创建一个包含 <code>&#123;&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30&#125;</code> 的 JSON 文件，你可以运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jq -n <span class="string">&#x27;&#123;&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30&#125;&#x27;</span> &gt; output.json</span><br></pre></td></tr></table></figure>

<p>这将会创建一个名为 <code>output.json</code> 的新文件，其中包含你指定的 JSON 数据。</p>
<p>如果你想要使用 Bash 变量创建 JSON 文件，你可以使用 <code>--arg</code> 选项将 Bash 变量传递给 <code>jq</code>。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name=<span class="string">&quot;John&quot;</span></span><br><span class="line">age=30</span><br><span class="line"></span><br><span class="line">jq -n --arg name <span class="string">&quot;<span class="variable">$name</span>&quot;</span> --argjson age <span class="string">&quot;<span class="variable">$age</span>&quot;</span> <span class="string">&#x27;&#123;&quot;name&quot;: $name, &quot;age&quot;: $age&#125;&#x27;</span> &gt; output.json</span><br></pre></td></tr></table></figure>

<p>jq -n –argjson cpu_temperature “$cpu_temperature” –argjson gpu_temperature “$gpu_temperature” ‘{“cpu”: $cpu_temperature, “gpu”: $gpu_temperature}’ &gt; output.json</p>
<p>这将会创建一个名为 <code>output.json</code> 的新文件，其中包含 <code>&#123;&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30&#125;</code>。注意，我们使用 <code>--argjson</code> 选项传递了一个整数变量 <code>age</code>，因为 JSON 中的数字不应被引号包围。</p>
<h1 id="linux-notebook-ban-suspend"><a href="#linux-notebook-ban-suspend" class="headerlink" title="linux notebook ban suspend"></a>linux notebook ban suspend</h1><p>sudo nano &#x2F;etc&#x2F;systemd&#x2F;logind.conf<br>HandleLidSwitch&#x3D;ignore</p>
<p>HandleLidSwitch&#x3D;ignore<br>HandleLidSwitchExternalPower&#x3D;ignore<br>HandleLidSwitchDocked&#x3D;ignore<br>LidSwitchIgnoreInhibited&#x3D;no</p>
<p>reboot needed</p>
<h1 id="uninstall-cuda"><a href="#uninstall-cuda" class="headerlink" title="uninstall cuda"></a>uninstall cuda</h1><p>sudo apt-get –purge remove “<em>cuda</em>“ “<em>cublas</em>“ “<em>cufft</em>“ “<em>cufile</em>“ “<em>curand</em>“ <br> “<em>cusolver</em>“ “<em>cusparse</em>“ “<em>gds-tools</em>“ “<em>npp</em>“ “<em>nvjpeg</em>“ “nsight*” “<em>nvvm</em>“</p>
<p>sudo apt-get –purge remove “<em>nvidia</em>“ “libxnvctrl*”</p>
<p>sudo apt-get autoremove</p>
<p>sudo apt-get –purge remove “<em>cuda</em>“ “<em>cublas</em>“ “<em>cufft</em>“ “<em>cufile</em>“ “<em>curand</em>“ “<em>cusolver</em>“ “<em>cusparse</em>“ “<em>gds-tools</em>“ “<em>npp</em>“ “<em>nvjpeg</em>“ “nsight*” “<em>nvvm</em>“ “<em>nvidia</em>“ “libxnvctrl*” &amp;&amp; sudo apt-get autoremove &amp;&amp; sudo reboot</p>
<h1 id="remove-docker-from-apt-update"><a href="#remove-docker-from-apt-update" class="headerlink" title="remove docker from apt update"></a>remove docker from apt update</h1><p>&#x2F;etc&#x2F;apt&#x2F;keyrings&#x2F;docker.gpg<br>&#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;docker.list</p>
<p>如果你想在运行 <code>apt update</code> 时跳过 Docker 的更新，你可以将 Docker 的软件源从 APT 的源列表中移除，或者将其禁用。</p>
<p>以下是如何禁用特定的 APT 源的步骤：</p>
<ol>
<li><p>打开 APT 源列表文件。这个文件通常位于 <code>/etc/apt/sources.list</code>，或者 <code>/etc/apt/sources.list.d/</code> 目录下的某个文件。你需要使用 root 权限来编辑这个文件，例如使用 <code>sudo nano /etc/apt/sources.list</code> 命令。</p>
</li>
<li><p>在文件中找到 Docker 的源。这个源的地址通常会包含 <code>https://download.docker.com/</code>。</p>
</li>
<li><p>在源的行前面加上 <code>#</code> 符号，这会将这一行变成注释，从而禁用这个源。例如，将</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deb [<span class="built_in">arch</span>=amd64] https://download.docker.com/linux/ubuntu bionic stable</span><br></pre></td></tr></table></figure>

<p> 改为</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>保存并关闭文件。</p>
</li>
<li><p>运行 <code>sudo apt update</code>。这次更新应该会跳过 Docker 的更新。</p>
</li>
</ol>
<p>如果你之后想要更新 Docker，你可以去掉那一行前面的 <code>#</code> 符号，然后再运行 <code>sudo apt update</code>。</p>
<h1 id="shebang"><a href="#shebang" class="headerlink" title="shebang"></a>shebang</h1><p>在 Linux 和 Unix 系统中，<code>shebang</code> 是一个特殊的注释，用于指定一个脚本文件的解释器。<code>shebang</code> 通常出现在脚本文件的第一行，并以 <code>#!</code> 开头，后面跟着解释器的路径。</p>
<p>#!&#x2F;usr&#x2F;bin&#x2F;env python3</p>
<p>nvitop</p>
<h1 id="nvidia-smi-ecc-报错"><a href="#nvidia-smi-ecc-报错" class="headerlink" title="nvidia-smi ecc 报错"></a>nvidia-smi ecc 报错</h1><p>nvidia-smi -q -d ECC</p>
<p>for i in <code>seq 3 644</code>; do if [ -f a_”$i”<em>1&#x2F;zfs.json ] &amp;&amp; [ -f a</em>“$i”<em>1.5&#x2F;zfs.json ] &amp;&amp; [ -f a</em>“$i”<em>-1&#x2F;zfs.json ] &amp;&amp; [ -f a</em>“$i”_-1.5&#x2F;zfs.json ]; then echo $i; fi; done</p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/06/15/wsl/" rel="prev" title="wsl">
                  <i class="fa fa-angle-left"></i> wsl
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/06/15/resource-management/" rel="next" title="resource_management">
                  resource_management <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Mingzhe Liu</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
